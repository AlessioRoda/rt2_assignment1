# First Assignment of the Research Track 2 course (action branch), developper Alessio Roda 4458313

The purpose of this package is to create a simulation in wich the robot follows some random positions generated by the a random server and reach it.
In this branch respect to the main branch, the code to move it is implemented as an action, so that the robot can stop before it reaches a defined position.
The genral idea to do that is to set the position the robot has to reach as an action, so when user asks to stop the robot the positionGoal to reach is cancelled and the robot is stopped in the current position.

## Description of the architecture
 
 The code was developped for ros noetic, so make sure you have this distribution in your computer before start, it's not guaranteed that it can work also with other distributions. The entire architecture is based on four nodes:
 
 1) user_interface which provides an interface to ask to the user to insert "1" to make the robot reach a random position and "0" to stop it, then it sends the command that user has choosen with the Command message.
 2) go_to_point is an action server used to reach a goal, it contains the code to make the robot move an holonomic robot in the space.
 3) random_position_server generate a random position and send it with RandomPosition message.
 4) state_machine is the "main" of the architecture: it gets the commad message and if it's "start", it publish the position the robot has to reach by setting the coordinates it takes from the RandomPosition message. Then it checks if user want to stop the robot and in case it provides to cancel the goal position to reach.
 
 In this package there are six folders:
 
 * action
 * launch
 * scripts
 * src
 * srv
 * urdf

There is also a docs folder wich contains a deeper documentation about the code, please have a look to it to understand in detail what every code do, here below there's a more "superficial" description about what the folders contains and what is changed respect to the main branch.

The first folder contains a file Position.action, due to the fact that in this implementation the position setting of the robot is implemented as an action.
 
The "launch" one contains two launch files
 
 * sim.launch
 * sim2.launch
 
 which respectively are the launch files to run the simulation with gazeebo simulator and with the Coppelia scene. The two files are almost identical, everyone launch all the nodes that are developped for the simulation, but the second launch file don't launch the gazeebo simulation, so that it's more comfortable to use when you have to launch the coppelia simulation.
 
"scripts" contains the two scripts that were implemented also in the main branch. In this case the script "user_interface.py" is the same as in main branch, while the "go_to_point.py" one has small modifiations in the main and in the go_to_point function to stop the robot before it reaches the current goal.

In "src" there are the "position_service.cpp" and "state_machine.cpp" codes, the first one is tha same as in main branch, while "state_machine.cpp" was modified in order to istanciate the postion that the robot has to reach as an action goal, so once the goal is created and configured with the same parameters as Position.srv in main branch had (x, y, theta) it's send to the "/go_to_point.py" node. Then the "/state_machine" node execute an infinite loop in wich it verifies that the user has cancelled the goal and in this case provides to delate the goal and set the linear and angular velcity of the robot to zero in order to stop it.

The "srv" folder contains the Command.srv and RandomPosition.srv files wich contains the information for the message respectively for the command that the user provides in the "/user_interface" node, and the position that robot has to reach provided by the "/random_position_server" node.

Finally "urdf" is a folder wich contains the description of the robot we are using in the simulation.

In the package there's also the "coppeliaScene.ttt" scene, wich has to be laded in Coppelia simulator in order to see the Coppelia simulation.

## Behaviour of the architecture

Here there's the rqt_graph of the architecture for each kind of simulation performed.


 
 

