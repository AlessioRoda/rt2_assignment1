# First Assignment of the Research Track 2 course (action branch), Alessio Roda 4458313

The purpose of this package is to create a simulation in which the robot follows some random positions generated by a random server and reach them.
In this branch respect to the main branch, the code to move is implemented as an action, so that the robot can stop before it reaches a defined position.
The general idea to do that is to set the position the robot has to reach as an action, so when user asks to stop the robot the positionGoal to reach is cancelled and the robot is stopped in the current position.

## Description of the architecture
 
 The code was developed for ros noetic, so make sure you have this distribution in your computer before start, it's not guaranteed that it can work also with other distributions. The entire architecture is based on four nodes:
 
 1) user_interface which provides an interface to ask to the user to insert "1" to make the robot reach a random position and "0" to stop it, then it sends the command that user has choosen with the Command custom service message.
 2) go_to_point is an action server used to reach a goal, it contains the code to move a non-holonomic robot in the space.
 3) random_position_server generate a random position in a defined interval and send it with RandomPosition custom service message.
 4) state_machine is the "main" of the architecture: it gets the command custom service message and if it is equal to "start", it publishes the position the robot has to reach by setting the coordinates it takes from the RandomPosition custom service message. Then it checks if user want to stop the robot and in case it provides to cancel the goal position to reach.
 
 In this package there are six folders:
 
 * action
 * launch
 * scripts
 * src
 * srv
 * urdf

There is also a docs folder which contains a deeper documentation about the code, please have a look to it to understand in detail what every code do, here below there's a more "superficial" description about what the folders contain and what is changed in respect to the main branch.

The first folder contains a file Position.action, due to the fact that in this implementation the position setting of the robot is implemented as an action. It is basically the same Psition.srv file that you can find in the main, with the same parameters.
 
The "launch" one contains two launch files
 
 * sim.launch
 * sim2.launch
 
 Which respectively are the launch files to run the simulation with gazebo simulator and with the Coppelia scene. The two files are almost identical, everyone launch all the nodes that are developed for the simulation, but the second launch file don't launch the gazebo simulation, so that it's more comfortable to use when you have to launch the coppelia simulation.
 
"scripts" contains the two scripts that were implemented also in the main branch. In this case the script "user_interface.py" is the same as in main branch, while the "go_to_point.py" one has small modifications in the main and in the go_to_point function to stop the robot before it reaches the current goal.

In "src" there are the "position_service.cpp" and "state_machine.cpp" files, the first one is the same as in main branch, while "state_machine.cpp" was modified in order to instantiate the position that the robot has to reach as an action goal, so once the goal is created and configured with the Posiation.action parameters (x, y, theta) it's send to the "/go_to_point.py" node. Then the "/state_machine" node executes an infinite loop in which it checks if the user has cancelled the goal and in this case provides to delete the goal and set the linear and angular velocity of the robot to zero in order to stop it.

The "srv" folder contains the Command.srv and RandomPosition.srv files which contains the information for the message respectively for the command that the user provides in the "/user_interface" node, and the position that robot has to reach provided by the "/random_position_server" node.

Finally "urdf" is a folder which contains the description of the robot we are using in the simulation.

In the package there's also the "coppeliaScene.ttt" scene, which has to be laded in Coppelia simulator in order to see the Coppelia simulation.


## Behavior of the architecture

Here there's the rqt_graph of the architecture for each kind of simulation performed.

![action_rosgraph](https://user-images.githubusercontent.com/48511957/118813342-4fa60500-b8af-11eb-8e69-ae6ad29f1738.png)
 
 
Here as it's possible to notice, the /state_machine node sends a goal to /go_to_point and receives a feedback about the state of the robot state and send a /cmd_vel message to gazebo since in case the goal is cancelled it has to force the robot to stop by changing its velocity. Since the simulation is performed with gazebo the /odom and /cmd_vel messages are send to it in order to move the robot.

Here the Coppelia simulation

![coppelia_action_rosgraph](https://user-images.githubusercontent.com/48511957/118832101-9ea86600-b8c0-11eb-8234-d4f7ad7a7476.png)

The considerations about the shared messages are the same as the gazebo simulation.

### Possible improvements

By having a look to the rqt_graphs and to the general composition of the entire architecture, we can notice that the only node that should send /cmd_vel messages should probably be only /go_to_point. In this case when the goal is cancelled the /state_machine node provides to set to zero the linear and angular velocity of the robot, but the node that has to perform this kind of operation could only be /go_to_point, in order to separate the diverse tasks in the architecture.

## How to run the code 

There are two possible ways to run this code dependently from the kind of simulation you prefer

### Gazebo simulation

To launch the Gazebo simulation you just have to clone the rt2_assignment1 action branch inside your_ros_workspace/src folder, then make sure you are using ros noetic inside your .bashrc file and type from terminal in your_ros_workspace the following instructions below: 

```
roscore &
```
```
catkin_make
```
```
roslaunch rt2_assignment1 sim.launch
```
Now the gazebo simulation and the terminal user interface should appear automatically; what you should notice is the interface who asks you to type 1 to move the robot and 0 to stop it

### Coppelia simulation

For this simulation it is necessary to install the Coppelia simulator, you can find here the link to install it https://www.coppeliarobotics.com/downloads.
Please notice that you should enlarge your Coppelia scene once you have installed it in order to run correctly the simulation.

In the scene that you can find here the values of the velocity of the motors has been incremented in order to make the simulation faster, so the velocity of the motors in Coppelia is bigger than the velocity that you can read by running rostopic echo /cmd_vel.


As before you have to clone the rt2_assignment1 action branch inside your_ros_workspace/src folder and make sure you are using ros noetic inside your .bashrc file. Now before launching the nodes execute 

```
roscore &
```
then open the Coppelia simulator and upload the "coppeliaScene.ttt" that you have in this package. Note: it's important to run "roscore" before opening Coppelia in order to load ROS on it.

Now type from terminal in your_ros_workspace

```
catkin_make
```
```
roslaunch rt2_assignment1 sim2.launch
```
Now once the terminal user interface is ready you can run the simulation in the Coppelia simulator, then by typing '1' in the previous terminal the robot starts moving.
