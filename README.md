# First Assignment of the Research Track 2 course (action branch), developper Alessio Roda 4458313

The purpose of this package is to create a simulation in wich the robot follows some random positions generated by the a random server and reach it.
In this branch respect to the main branch, the code to move it is implemented as an action, so that the robot can stop before it reaches a defined position.
The genral idea to do that is to set the position the robot has to reach as an action, so when user asks to stop the robot the positionGoal to reach is cancelled and the robot is stopped in the current position.

## Description of the architecture
 
 The code was developped for ros noetic, so make sure you have this distribution in your computer before start, it's not guaranteed that it can work also with other distributions. The entire architecture is based on four nodes:
 
 1) user_interface which provides an interface to ask to the user to insert "1" to make the robot reach a random position and "0" to stop it, then it sends the command that user has choosen with the Command custom service message.
 2) go_to_point is an action server used to reach a goal, it contains the code to make the robot move an holonomic robot in the space.
 3) random_position_server generate a random position and send it with RandomPosition custom service message.
 4) state_machine is the "main" of the architecture: it gets the commad custom service message and if it's "start", it publish the position the robot has to reach by setting the coordinates it takes from the RandomPosition custom service message. Then it checks if user want to stop the robot and in case it provides to cancel the goal position to reach.
 
 In this package there are six folders:
 
 * action
 * launch
 * scripts
 * src
 * srv
 * urdf

There is also a docs folder wich contains a deeper documentation about the code, please have a look to it to understand in detail what every code do, here below there's a more "superficial" description about what the folders contains and what is changed respect to the main branch.

The first folder contains a file Position.action, due to the fact that in this implementation the position setting of the robot is implemented as an action.
 
The "launch" one contains two launch files
 
 * sim.launch
 * sim2.launch
 
 which respectively are the launch files to run the simulation with gazeebo simulator and with the Coppelia scene. The two files are almost identical, everyone launch all the nodes that are developped for the simulation, but the second launch file don't launch the gazeebo simulation, so that it's more comfortable to use when you have to launch the coppelia simulation.
 
"scripts" contains the two scripts that were implemented also in the main branch. In this case the script "user_interface.py" is the same as in main branch, while the "go_to_point.py" one has small modifiations in the main and in the go_to_point function to stop the robot before it reaches the current goal.

In "src" there are the "position_service.cpp" and "state_machine.cpp" codes, the first one is tha same as in main branch, while "state_machine.cpp" was modified in order to istanciate the postion that the robot has to reach as an action goal, so once the goal is created and configured with the same parameters as Position.srv in main branch had (x, y, theta) it's send to the "/go_to_point.py" node. Then the "/state_machine" node execute an infinite loop in wich it verifies that the user has cancelled the goal and in this case provides to delate the goal and set the linear and angular velcity of the robot to zero in order to stop it.

The "srv" folder contains the Command.srv and RandomPosition.srv files wich contains the information for the message respectively for the command that the user provides in the "/user_interface" node, and the position that robot has to reach provided by the "/random_position_server" node.

Finally "urdf" is a folder wich contains the description of the robot we are using in the simulation.

In the package there's also the "coppeliaScene.ttt" scene, wich has to be laded in Coppelia simulator in order to see the Coppelia simulation.


## Behaviour of the architecture

Here there's the rqt_graph of the architecture for each kind of simulation performed.

![action_rosgraph](https://user-images.githubusercontent.com/48511957/118813342-4fa60500-b8af-11eb-8e69-ae6ad29f1738.png)
 
 
Here as it's possible to notice, the /state_machine node sends a goal to /go_to_point and receives a feedback about the state of the robot state. Since the simulation is performed with gazeebo the /odom and /cmd_vel messages are send to it in order to move the robot.

Here the Coppelia simulation

![coppelia_action_rosgraph](https://user-images.githubusercontent.com/48511957/118832101-9ea86600-b8c0-11eb-8234-d4f7ad7a7476.png)

The considerations about the shared messages are the same as the gazeebo simulation.

### Possible improvements

By having a look to the rqt_graphs and to the genreal composition of the entire architecture, we can notice that the only node that should send /cmd_vel messages should probably be only /go_to_point. In this case when the goal is cancelled the /state_machine node provides to set the linear and angular velocity of the robot to zero, but the node that has to perform this kind of operation could only be /go_to_point, in order to separate the diverse tasks in the architecture.

## How to run the code 

There are two possible ways to run this code dependently from the kind of simulation you prefer

### Gazeebo simulation

To launch the Gazeebo simulation you just have to clone the rt2_assignment1 action branch inside your_ros_workspace/src folder, then make sure you are using ros noetic inside your .bashrc file and type from terminal in your_ros_workspace the following instructions below: 

```
roscore &
```
```
catkin_make
```
```
roslaunch rt2_assignment1 sim.launch
```
Now the gazeebo simulation and the termianl user interface should appear automatically; what you should notice is the interface who asks you to type 1 o move the robot and 0 to stop it

### Coppelia simulation

For this simulation it is necessary to install the Coppelia simulator, you can find here the link to install it https://www.coppeliarobotics.com/downloads.
Please notice that you should enlarge your Coppelia scene once you have installed it in order to run correctly the simulation.

In the scene that you can find here the values of the velocity of the motors has been incremented in order to make the simulation faster, so the velocity of the motor in Coppelia is bigger than the velocity that you can read by running rostopic echo /cmd_vel.


As before you have to clone the rt2_assignment1 action branch inside your_ros_workspace/src folder and make sure you are using ros noetic inside your .bashrc file. Now before launching the nodes execute 

```
roscore &
```
then open the Coppelia simulator and upload the "coppeliaScene.ttt" that you have in this package. Note: it's important to run "roscore" before opening Coppelia in order to load ROS on it.

Now type from terminal in your_ros_workspace

```
catkin_make
```
```
roslaunch rt2_assignment1 sim2.launch
```
Now once the terminal user interface is ready you can run the simulation in the Coppelia simulator, then by typing '1' in the previous terminal the robot statrs moving.
