<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: First Assignment of the Research Track 2 course (action branch), Alessio Roda 4458313</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">First Assignment of the Research Track 2 course (action branch), Alessio Roda 4458313 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The purpose of this package is to create a simulation in which the robot follows some random positions generated by a random server and reach them. In this branch respect to the main branch, the code to move is implemented as an action, so that the robot can stop before it reaches a defined position. The general idea to do that is to set the position the robot has to reach as an action, so when user asks to stop the robot the positionGoal to reach is cancelled and the robot is stopped in the current position.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Description of the architecture</h1>
<p>The code was developed for ros noetic, so make sure you have this distribution in your computer before start, it's not guaranteed that it can work also with other distributions. The entire architecture is based on four nodes:</p>
<p>1) <a class="el" href="namespaceuser__interface.html">user_interface</a> which provides an interface to ask to the user to insert "1" to make the robot reach a random position and "0" to stop it, then it sends the command that user has choosen with the Command custom service message. 2) <a class="el" href="namespacego__to__point.html">go_to_point</a> is an action server used to reach a goal, it contains the code to move a non-holonomic robot in the space. 3) random_position_server generate a random position in a defined interval and send it with RandomPosition custom service message. 4) state_machine is the "main" of the architecture: it gets the command custom service message and if it is equal to "start", it publishes the position the robot has to reach by setting the coordinates it takes from the RandomPosition custom service message. Then it checks if user want to stop the robot and in case it provides to cancel the goal position to reach.</p>
<p>In this package there are six folders:</p>
<ul>
<li>action</li>
<li>launch</li>
<li>scripts</li>
<li>src</li>
<li>srv</li>
<li>urdf</li>
</ul>
<p>There is also a docs folder which contains a deeper documentation about the code, please have a look to it to understand in detail what every code do, here below there's a more "superficial" description about what the folders contain and what is changed in respect to the main branch.</p>
<p>The first folder contains a file Position.action, due to the fact that in this implementation the position setting of the robot is implemented as an action. It is basically the same Psition.srv file that you can find in the main, with the same parameters.</p>
<p>The "launch" one contains two launch files</p>
<ul>
<li>sim.launch</li>
<li>sim2.launch</li>
</ul>
<p>Which respectively are the launch files to run the simulation with gazebo simulator and with the Coppelia scene. The two files are almost identical, everyone launch all the nodes that are developed for the simulation, but the second launch file don't launch the gazebo simulation, so that it's more comfortable to use when you have to launch the coppelia simulation.</p>
<p>"scripts" contains the two scripts that were implemented also in the main branch. In this case the script "user_interface.py" is the same as in main branch, while the "go_to_point.py" one has small modifications in the main and in the <a class="el" href="namespacego__to__point.html">go_to_point</a> function to stop the robot before it reaches the current goal.</p>
<p>In "src" there are the "position_service.cpp" and "state_machine.cpp" files, the first one is the same as in main branch, while "state_machine.cpp" was modified in order to instantiate the position that the robot has to reach as an action goal, so once the goal is created and configured with the Posiation.action parameters (x, y, theta) it's send to the "/go_to_point.py" node. Then the "/state_machine" node executes an infinite loop in which it checks if the user has cancelled the goal and in this case provides to delete the goal.</p>
<p>The "srv" folder contains the Command.srv and RandomPosition.srv files which contains the information for the message respectively for the command that the user provides in the "/user_interface" node, and the position that robot has to reach provided by the "/random_position_server" node.</p>
<p>Finally "urdf" is a folder which contains the description of the robot we are using in the simulation.</p>
<p>In the package there's also the "coppeliaScene.ttt" scene, which has to be laded in Coppelia simulator in order to see the Coppelia simulation.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Behavior of the architecture</h1>
<p>Here there's the rqt_graph of the architecture for each kind of simulation performed.</p>
<p><img src="https://user-images.githubusercontent.com/48511957/119021685-02559080-b9a0-11eb-8640-8ad4438f21a6.png" alt="gazebo_action" class="inline"/></p>
<p>Here as it's possible to notice, the /state_machine node sends a goal to /go_to_point and receives a feedback about the state of the robot state. Since the simulation is performed with gazebo the /odom and /cmd_vel messages are send to it in order to move the robot.</p>
<p>Here the Coppelia simulation</p>
<p><img src="https://user-images.githubusercontent.com/48511957/119022478-fddda780-b9a0-11eb-8351-f2ac4a1b373b.png" alt="coppelia_action" class="inline"/></p>
<p>The considerations about the shared messages are the same as the gazebo simulation.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
How to run the code</h1>
<p>There are two possible ways to run this code dependently from the kind of simulation you prefer</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Gazebo simulation</h2>
<p>To launch the Gazebo simulation you just have to clone the rt2_assignment1 action branch inside your_ros_workspace/src folder, then make sure you are using ros noetic inside your .bashrc file and type from terminal in your_ros_workspace the following instructions below:</p>
<div class="fragment"><div class="line">roscore &amp;</div>
</div><!-- fragment --><div class="fragment"><div class="line">catkin_make</div>
</div><!-- fragment --><div class="fragment"><div class="line">roslaunch rt2_assignment1 sim.launch</div>
</div><!-- fragment --><p>Now the gazebo simulation and the terminal user interface should appear automatically; what you should notice is the interface who asks you to type 1 to move the robot and 0 to stop it</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Coppelia simulation</h2>
<p>For this simulation it is necessary to install the Coppelia simulator, you can find here the link to install it <a href="https://www.coppeliarobotics.com/downloads">https://www.coppeliarobotics.com/downloads</a>. Please notice that you should enlarge your Coppelia scene once you have installed it in order to run correctly the simulation.</p>
<p>In the scene that you can find here the values of the velocity of the motors has been incremented in order to make the simulation faster, so the velocity of the motors in Coppelia is bigger than the velocity that you can read by running rostopic echo /cmd_vel.</p>
<p>As before you have to clone the rt2_assignment1 action branch inside your_ros_workspace/src folder and make sure you are using ros noetic inside your .bashrc file. Now before launching the nodes execute</p>
<div class="fragment"><div class="line">roscore &amp;</div>
</div><!-- fragment --><p>then open the Coppelia simulator and upload the "coppeliaScene.ttt" that you have in this package. Note: it's important to run "roscore" before opening Coppelia in order to load ROS on it.</p>
<p>Now type from terminal in your_ros_workspace</p>
<div class="fragment"><div class="line">catkin_make</div>
</div><!-- fragment --><div class="fragment"><div class="line">roslaunch rt2_assignment1 sim2.launch</div>
</div><!-- fragment --><p>Now once the terminal user interface is ready you can run the simulation in the Coppelia simulator, then by typing '1' in the previous terminal the robot starts moving. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
