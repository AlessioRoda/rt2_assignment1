The purpose of this package is to create a simulation in which the robot follows some random positions generated by a random server and reach them. In this branch respect to the main branch, the code to move is implemented as an action, so that the robot can stop before it reaches a defined position. The general idea to do that is to set the position the robot has to reach as an action, so when user asks to stop the robot the position\+Goal to reach is cancelled and the robot is stopped in the current position.\hypertarget{md__r_e_a_d_m_e_autotoc_md1}{}\doxysection{Description of the architecture}\label{md__r_e_a_d_m_e_autotoc_md1}
The code was developed for ros noetic, so make sure you have this distribution in your computer before start, it\textquotesingle{}s not guaranteed that it can work also with other distributions. The entire architecture is based on four nodes\+:

1) \mbox{\hyperlink{namespaceuser__interface}{user\+\_\+interface}} which provides an interface to ask to the user to insert \char`\"{}1\char`\"{} to make the robot reach a random position and \char`\"{}0\char`\"{} to stop it, then it sends the command that user has choosen with the Command custom service message. 2) \mbox{\hyperlink{namespacego__to__point}{go\+\_\+to\+\_\+point}} is an action server used to reach a goal, it contains the code to move a non-\/holonomic robot in the space. 3) random\+\_\+position\+\_\+server generate a random position in a defined interval and send it with Random\+Position custom service message. 4) state\+\_\+machine is the \char`\"{}main\char`\"{} of the architecture\+: it gets the command custom service message and if it is equal to \char`\"{}start\char`\"{}, it publishes the position the robot has to reach by setting the coordinates it takes from the Random\+Position custom service message. Then it checks if user want to stop the robot and in case it provides to cancel the goal position to reach.

In this package there are six folders\+:


\begin{DoxyItemize}
\item action
\item launch
\item scripts
\item src
\item srv
\item urdf
\end{DoxyItemize}

There is also a docs folder which contains a deeper documentation about the code, please have a look to it to understand in detail what every code do, here below there\textquotesingle{}s a more \char`\"{}superficial\char`\"{} description about what the folders contain and what is changed in respect to the main branch.

The first folder contains a file Position.\+action, due to the fact that in this implementation the position setting of the robot is implemented as an action. It is basically the same Psition.\+srv file that you can find in the main, with the same parameters.

The \char`\"{}launch\char`\"{} one contains two launch files


\begin{DoxyItemize}
\item sim.\+launch
\item sim2.\+launch
\end{DoxyItemize}

Which respectively are the launch files to run the simulation with gazebo simulator and with the Coppelia scene. The two files are almost identical, everyone launch all the nodes that are developed for the simulation, but the second launch file don\textquotesingle{}t launch the gazebo simulation, so that it\textquotesingle{}s more comfortable to use when you have to launch the coppelia simulation.

\char`\"{}scripts\char`\"{} contains the two scripts that were implemented also in the main branch. In this case the script \char`\"{}user\+\_\+interface.\+py\char`\"{} is the same as in main branch, while the \char`\"{}go\+\_\+to\+\_\+point.\+py\char`\"{} one has small modifications in the main and in the \mbox{\hyperlink{namespacego__to__point}{go\+\_\+to\+\_\+point}} function to stop the robot before it reaches the current goal.

In \char`\"{}src\char`\"{} there are the \char`\"{}position\+\_\+service.\+cpp\char`\"{} and \char`\"{}state\+\_\+machine.\+cpp\char`\"{} files, the first one is the same as in main branch, while \char`\"{}state\+\_\+machine.\+cpp\char`\"{} was modified in order to instantiate the position that the robot has to reach as an action goal, so once the goal is created and configured with the Posiation.\+action parameters (x, y, theta) it\textquotesingle{}s send to the \char`\"{}/go\+\_\+to\+\_\+point.\+py\char`\"{} node. Then the \char`\"{}/state\+\_\+machine\char`\"{} node executes an infinite loop in which it checks if the user has cancelled the goal and in this case provides to delete the goal.

The \char`\"{}srv\char`\"{} folder contains the Command.\+srv and Random\+Position.\+srv files which contains the information for the message respectively for the command that the user provides in the \char`\"{}/user\+\_\+interface\char`\"{} node, and the position that robot has to reach provided by the \char`\"{}/random\+\_\+position\+\_\+server\char`\"{} node.

Finally \char`\"{}urdf\char`\"{} is a folder which contains the description of the robot we are using in the simulation.

In the package there\textquotesingle{}s also the \char`\"{}coppelia\+Scene.\+ttt\char`\"{} scene, which has to be laded in Coppelia simulator in order to see the Coppelia simulation.\hypertarget{md__r_e_a_d_m_e_autotoc_md2}{}\doxysection{Behavior of the architecture}\label{md__r_e_a_d_m_e_autotoc_md2}
Here there\textquotesingle{}s the rqt\+\_\+graph of the architecture for each kind of simulation performed.



Here as it\textquotesingle{}s possible to notice, the /state\+\_\+machine node sends a goal to /go\+\_\+to\+\_\+point and receives a feedback about the state of the robot state. Since the simulation is performed with gazebo the /odom and /cmd\+\_\+vel messages are send to it in order to move the robot.

Here the Coppelia simulation



The considerations about the shared messages are the same as the gazebo simulation.\hypertarget{md__r_e_a_d_m_e_autotoc_md3}{}\doxysection{How to run the code}\label{md__r_e_a_d_m_e_autotoc_md3}
There are two possible ways to run this code dependently from the kind of simulation you prefer\hypertarget{md__r_e_a_d_m_e_autotoc_md4}{}\doxysubsection{Gazebo simulation}\label{md__r_e_a_d_m_e_autotoc_md4}
To launch the Gazebo simulation you just have to clone the rt2\+\_\+assignment1 action branch inside your\+\_\+ros\+\_\+workspace/src folder, then make sure you are using ros noetic inside your .bashrc file and type from terminal in your\+\_\+ros\+\_\+workspace the following instructions below\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{roscore \&}
\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{catkin\_make}
\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{roslaunch rt2\_assignment1 sim.launch}
\end{DoxyCode}


Now the gazebo simulation and the terminal user interface should appear automatically; what you should notice is the interface who asks you to type 1 to move the robot and 0 to stop it\hypertarget{md__r_e_a_d_m_e_autotoc_md5}{}\doxysubsection{Coppelia simulation}\label{md__r_e_a_d_m_e_autotoc_md5}
For this simulation it is necessary to install the Coppelia simulator, you can find here the link to install it \href{https://www.coppeliarobotics.com/downloads}{\texttt{ https\+://www.\+coppeliarobotics.\+com/downloads}}. Please notice that you should enlarge your Coppelia scene once you have installed it in order to run correctly the simulation.

In the scene that you can find here the values of the velocity of the motors has been incremented in order to make the simulation faster, so the velocity of the motors in Coppelia is bigger than the velocity that you can read by running rostopic echo /cmd\+\_\+vel.

As before you have to clone the rt2\+\_\+assignment1 action branch inside your\+\_\+ros\+\_\+workspace/src folder and make sure you are using ros noetic inside your .bashrc file. Now before launching the nodes execute


\begin{DoxyCode}{0}
\DoxyCodeLine{roscore \&}
\end{DoxyCode}


then open the Coppelia simulator and upload the \char`\"{}coppelia\+Scene.\+ttt\char`\"{} that you have in this package. Note\+: it\textquotesingle{}s important to run \char`\"{}roscore\char`\"{} before opening Coppelia in order to load R\+OS on it.

Now type from terminal in your\+\_\+ros\+\_\+workspace


\begin{DoxyCode}{0}
\DoxyCodeLine{catkin\_make}
\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{roslaunch rt2\_assignment1 sim2.launch}
\end{DoxyCode}


Now once the terminal user interface is ready you can run the simulation in the Coppelia simulator, then by typing \textquotesingle{}1\textquotesingle{} in the previous terminal the robot starts moving. 