The purpose of this package is to create a simulation in which the robot follows some random positions generated by a random server and reach them. The robot can also stop if user order it, but only when it arrives in the last position that has to reach. In this branch respect to the main branch, the files \char`\"{}state\+\_\+machine.\+cpp\char`\"{} and \char`\"{}position\+\_\+service.\+cpp\char`\"{} are implemented as R\+O\+S2 component and the general architecture is divided in two parts\+: one developed with R\+O\+S2 component and the other one developed by maintaining the scripts of the main branch in R\+O\+S1. So by considering this, in order to run the code there will be an interaction between R\+O\+S1 and R\+O\+S2 that can be possible thanks to a \char`\"{}ros bridge\char`\"{}, if you haven\textquotesingle{}t installed it yet you can find the guide to download and install here\+: \href{https://github.com/ros2/ros1_bridge}{\texttt{ https\+://github.\+com/ros2/ros1\+\_\+bridge}}.

Before start remember to download the rt2\+\_\+assignment1 main branch in your ros workspace, since as said before it\textquotesingle{}s necessary in order to run the code.~\hypertarget{md__r_e_a_d_m_e_autotoc_md1}{}\doxysection{Description of the architecture}\label{md__r_e_a_d_m_e_autotoc_md1}
~ The code here was developed for ros2 foxy, so make sure that you have this distribution in your computer before start. This part of the architecture is based on two components\+: ~

~1) position\+\_\+service\+\_\+component generate a random position and send it with Random\+Position custom service message. ~\newline
 ~2) state\+\_\+machine\+\_\+component is the \char`\"{}main\char`\"{} of the architecture\+: it gets the command custom service message and if it\textquotesingle{}s \char`\"{}start\char`\"{}, it publishes the position the robot has to reach by setting the coordinates it takes from the Random\+Position custom service message. Then it checks if user wants to stop the robot and in case stop sending random positions to reach. ~\newline
 ~

In this package there are four folders\+: ~\newline



\begin{DoxyItemize}
\item launch
\item src
\item srv
\item urdf
\end{DoxyItemize}

There is also a docs folder which contains a deeper documentation about the code, please have a look to it to understand in detail what every code do, here below there\textquotesingle{}s a more \char`\"{}superficial\char`\"{} description about what the folders contain and what is changed in respect to the main branch.

~ The \char`\"{}launch\char`\"{} one contains the ros2\+\_\+sim.\+launch launch file which is the file to run the simulation with gazebo. The file provides to load the components in the rt2\+\_\+assignment1 container.

In \char`\"{}src\char`\"{} there are the \char`\"{}position\+\_\+service.\+cpp\char`\"{} and \char`\"{}state\+\_\+machine.\+cpp\char`\"{} codes, they have been developed as ros component and the scope of the code is to generate a random position that is sent from the \char`\"{}position\+\_\+service\+\_\+component\char`\"{} to the \char`\"{}state\+\_\+machine\+\_\+component\char`\"{} via Random\+Position custom message. When the component \char`\"{}state\+\_\+machine\+\_\+component\char`\"{} gets the position from the server it sets the parameters of the position to reach in a Position custom service message and sends to the /go\+\_\+to\+\_\+point node thanks to the ros bridge, then the robot starts moving to the target to reach. The \char`\"{}state\+\_\+machine\+\_\+component\char`\"{} performs a loop in which verifies if the user sends the 0 command in order to stop the robot; in this case \char`\"{}state\+\_\+machine\+\_\+component\char`\"{} won\textquotesingle{}t send a new target to reach once the current target position has been reached.~

The \char`\"{}srv\char`\"{} folder contains the Command.\+srv and Random\+Position.\+srv files which contain the information for the message respectively for the command that the user provides in the \char`\"{}/user\+\_\+interface\char`\"{} node, and the position that robot has to reach provided by the \char`\"{}/random\+\_\+position\+\_\+server\char`\"{} node.

Finally \char`\"{}urdf\char`\"{} is a folder that contains the description of the robot we are using in the simulation.

There are also the gazebo\+\_\+script.\+sh and mapping\+\_\+rules.\+yaml files, the first one is an executable to run the entire simulation, while the second one it\textquotesingle{}s necessary to compile the ros bridge in order to share the service custom messages between the two ros distributions.\hypertarget{md__r_e_a_d_m_e_autotoc_md2}{}\doxysection{Behaviour of the architecture}\label{md__r_e_a_d_m_e_autotoc_md2}
As said before the entire architecture is based either in R\+O\+S2 and R\+O\+S1 code thanks to the ros bridge; the scope of the bridge is to share the custom server messages Random\+Service, Position and Command from the R\+O\+S2 distribution to the R\+O\+S1 one. For what regards the sharing of messages between the nodes and the components it\textquotesingle{}s similar to what happens in action branch.\hypertarget{md__r_e_a_d_m_e_autotoc_md3}{}\doxysection{How to run the code}\label{md__r_e_a_d_m_e_autotoc_md3}
First before running the code make sure you have downloaded the ros bridge, you will have to compile it again in order to permit it to share the custom service messages. Once you have done this there are different ways to run the code\hypertarget{md__r_e_a_d_m_e_autotoc_md4}{}\doxysubsection{Run with gazeebo\+\_\+script.\+sh}\label{md__r_e_a_d_m_e_autotoc_md4}
In this case you need to install gnome-\/terminal with


\begin{DoxyCode}{0}
\DoxyCodeLine{install gnome-\/terminal}
\end{DoxyCode}


The easiest way to launch the entire simulation is just to copy and paste the gazebo\+\_\+script.\+sh file in the root folder, then you have to provide to create in the root folder three files\+: ros.\+sh, ros2.\+sh, ros12.\+sh. These files are necessary to set the correct ros distribution in the terminal.~~

In case you have to create them you can just copy and paste~

ros.\+sh\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\#!/bin/bash}
\DoxyCodeLine{source your\_ros1\_work\_space/devel/setup.bash}
\end{DoxyCode}


ros2.\+sh\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\#!/bin/bash}
\DoxyCodeLine{source your\_ros2\_work\_space/install/setup.bash}
\end{DoxyCode}


ros12.\+sh\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\#!/bin/bash}
\DoxyCodeLine{source your\_ros1\_work\_space/devel/setup.bash}
\DoxyCodeLine{source your\_ros2\_work\_space/install/setup.bash}
\end{DoxyCode}


Make sure that these files and the gazebo\+\_\+script one have the permission to be executable.

Now the only thing that you have to do in order to launch the entire simulation is to open the terminal in the root folder ad digit~


\begin{DoxyCode}{0}
\DoxyCodeLine{./gazebo\_script.sh}
\end{DoxyCode}


Now three different terminals should have been opened and you can find the user terminal interface to move the robot in the first one.\hypertarget{md__r_e_a_d_m_e_autotoc_md5}{}\doxysubsection{Run by launching the nodes and the components via terminal}\label{md__r_e_a_d_m_e_autotoc_md5}
To run the simulation without launching the file you can create a terminal in your\+\_\+ros1\+\_\+workspace and configure it with ros1, then type~


\begin{DoxyCode}{0}
\DoxyCodeLine{roslaunch rt2\_assignment1 sim\_bridge.launch}
\end{DoxyCode}


Now open another terminal, configure it with both ros1 and ros2, then in your workspace run the ros bridge by typing


\begin{DoxyCode}{0}
\DoxyCodeLine{ros2 run ros1\_bridge dynamic\_bridge}
\end{DoxyCode}


Finally open another terminal, configure it with ros2, then in your workspace run


\begin{DoxyCode}{0}
\DoxyCodeLine{ros2 launch rt2\_assignment1 ros2\_sim.py}
\end{DoxyCode}
 